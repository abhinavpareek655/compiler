package Syntactic;

import lexical.Token;
import java.io.IOException;
import java.util.*;

public class Parser {
    private final List<Token> tokens;
    private int currentIndex;
    private Token currentToken;
    private final Stack<String> parseStack;
    private final Map<String, Map<String, List<String>>> parseTable;

    private final StringBuilder syntaxErrors;
    private final String fileName;
    private int errorCount = 0;
    private static final int MAX_ERRORS = 50;

    private final DerivationBuilder derivationBuilder;
    private final ErrorFileGenerator errorFileGenerator;

    private static final Set<String> TERMINALS = Set.of(
            "class", "id", "isa", "lbrace", "rbrace", "semicolon", "public", "private",
            "function", "constructor", "lparen", "rparen", "arrow", "void",
            "local", "attribute", "colon", "int", "float", "assign", "if", "then",
            "else", "while", "read", "write", "return", "lsqbr", "rsqbr", "comma",
            "eq", "neq", "lt", "gt", "lteq", "gteq", "addition", "subtraction", "or", "not",
            "*", "/", "and", "self", "floatlit", "intlit", "dot", "implementation", "ε", "comment", "multi_line_comment", "$"
    );

    /**
     * Constructor for the Parser class.
     *
     * @param tokens   The list of tokens generated by the lexical analyzer.
     * @param fileName The name of the file being parsed.
     * @throws IOException If an I/O error occurs during initialization.
     */
    public Parser(List<Token> tokens, String fileName) throws IOException {
        this.tokens = tokens;
        this.fileName = fileName;
        this.currentIndex = 0;
        this.currentToken = getNextToken();
        this.parseStack = new Stack<>();
        this.syntaxErrors = new StringBuilder();
        this.parseTable = buildParseTable();

        this.derivationBuilder = new DerivationBuilder(fileName);
        this.errorFileGenerator = new ErrorFileGenerator();
    }

    /**
     * Retrieves the next token from the token list.
     *
     * @return The next token, or null if no more tokens are available.
     */
    private Token getNextToken() {
        return currentIndex < tokens.size() ? tokens.get(currentIndex++) : null;
    }

    private boolean isCommentToken(Token token) {
        String type = token.getTokenType().toString().toLowerCase();
        return type.equals("multi_line_comment") || type.equals("single_line_comment");
    }

    public void parse() throws IOException {
        while (currentToken != null && isCommentToken(currentToken)) {
            currentToken = getNextToken();
        }
        parseStack.push("$");
        parseStack.push("START");

        derivationBuilder.appendStep("START");

        // Skip comments first
        while (currentToken != null && (currentToken.getTokenType().toString().equals("multi_line_comment") ||
                currentToken.getTokenType().toString().equals("single_line_comment"))) {
            currentToken = getNextToken();
        }

        while (!parseStack.isEmpty() && errorCount < MAX_ERRORS) {
            String top = parseStack.peek();
            String currentType = currentToken != null ? currentToken.getTokenType().toString().toLowerCase() : "$";

            // If we reach the end of tokens
            if (currentToken == null && !top.equals("$")) {
                reportError("Unexpected end of input", top);
                break;
            }

            if (top.equals("ε")) {
                parseStack.pop();
                continue;
            }

            if (isTerminal(top)) {
//                System.out.println("isTerminal - "+ top);
                matchTerminal(top);
            } else {
                expandNonTerminal(top, currentType);
            }

            // Skip over comments between parsing steps
            while (currentToken != null && (currentToken.getTokenType().toString().equals("multi_line_comment") ||
                    currentToken.getTokenType().toString().equals("single_line_comment"))) {
                currentToken = getNextToken();
            }
        }
        outputResults();
    }

    /**
     * Checks if a given symbol is a terminal.
     *
     * @param symbol The symbol to check.
     * @return True if the symbol is a terminal, false otherwise.
     */
    public static boolean isTerminal(String symbol) {
        return TERMINALS.contains(symbol);
    }

    /**
     * Matches the current token with the expected terminal.
     *
     * @param expected The expected terminal symbol.
     * @throws IOException If an I/O error occurs during matching.
     */
    private void matchTerminal(String expected) throws IOException {
        if (currentToken == null) {
            reportError("Unexpected end of file", expected);
            return;
        }
        String actual = currentToken.getTokenType().toString().toLowerCase();

        if (expected.equals(actual)) {
            parseStack.pop();
            derivationBuilder.appendStep("Matched terminal: " + expected);
            if (!parseStack.isEmpty() && !parseStack.peek().equals("$")) {
                currentToken = getNextToken();
            }
        } else {
            System.out.println("hiiii");
            reportError("Unexpected token '" + actual + "'", expected);
            if (!isSyncToken()) {
                currentToken = getNextToken(); // Move only if it's not a sync token
            }
        }
    }

    /**
     * Expands a non-terminal symbol using the parse table.
     *
     * @param nonTerminal The non-terminal symbol to expand.
     * @param lookahead   The current lookahead token type.
     * @throws IOException If an I/O error occurs during expansion.
     */
    private void expandNonTerminal(String nonTerminal, String lookahead) throws IOException {
        parseStack.pop();

        if (!parseTable.containsKey(nonTerminal)) {
            reportError("Unexpected non-terminal: " + nonTerminal, lookahead);
            recoverFromError();
            return;
        }

        Map<String, List<String>> row = parseTable.get(nonTerminal);

        if (row.containsKey(lookahead)) {
            List<String> production = row.get(lookahead);
            derivationBuilder.appendStep(nonTerminal + " -> " + String.join(" ", production));
            pushProduction(production);
        } else if (row.containsKey("ε")) {
            derivationBuilder.appendStep(nonTerminal + " -> ε");
        } else {
            reportError("No valid production for non-terminal '" + nonTerminal + "' with lookahead '" + lookahead + "'", lookahead);

            // Improved Error Handling: Skip tokens until a valid one is found
            while (currentToken != null && !row.containsKey(currentToken.getTokenType().toString().toLowerCase())
                    && !isSyncToken()) {
                currentToken = getNextToken();
            }
        }
    }

    /**
     * Pushes a production rule onto the parse stack in reverse order.
     *
     * @param production The production rule to push onto the stack.
     */
    private void pushProduction(List<String> production) {
        for (int i = production.size() - 1; i >= 0; i--) {
            String symbol = production.get(i);
            if (!symbol.equals("ε")) {
                parseStack.push(symbol);
            }
        }
    }

    /**
     * Reports a syntax error and increments the error count.
     *
     * @param message   The error message.
     * @param expected The expected token or symbol.
     */
    private void reportError(String message, String expected) {
        syntaxErrors.append(String.format("Error [Line %d]: %s, expected '%s'\n",
                currentToken != null ? currentToken.getTokenPosition() : -1,
                message,
                expected
        ));
        errorCount++;
    }

    /**
     * Recovers from a syntax error by skipping tokens until a synchronization point is found.
     */
    private void recoverFromError() {
        while (currentToken != null && !isSyncToken()) {
            currentToken = getNextToken();
        }

        // Ensure stack is not entirely popped
        while (!parseStack.isEmpty() && !isSyncNonTerminal(parseStack.peek())) {
            parseStack.pop();
        }

        // If stack was emptied incorrectly, restart parsing from "START"
        if (currentToken != null && parseStack.isEmpty()) {
            parseStack.push("START");
        }
    }

    /**
     * Checks if the current token is a synchronization token.
     *
     * @return True if the current token is a synchronization token, false otherwise.
     */
    private boolean isSyncToken() {
        if (currentToken == null) return true;
        String type = currentToken.getTokenType().toString().toLowerCase();
        return Set.of("semicolon", "rcp", "RBP", "rsqbr",
                "then", "else", "function", "class", "$").contains(type);
    }

    /**
     * Checks if a given symbol is a synchronization non-terminal.
     *
     * @param symbol The symbol to check.
     * @return True if the symbol is a synchronization non-terminal, false otherwise.
     */
    private boolean isSyncNonTerminal(String symbol) {
        return Set.of("PROG", "CLASSIMPLFUNC", "STATEMENT", "STATBLOCK").contains(symbol);
    }

    /**
     * Builds the parse table for the grammar.
     *
     * @return A map representing the parse table.
     */
    private Map<String, Map<String, List<String>>> buildParseTable() {
        Map<String, Map<String, List<String>>> table = new HashMap<>();

        // START rule
        addEntry(table, "START", List.of("function", "class", "implementation", "$"), List.of("PROG"));
        addEntry(table, "START", List.of("comment"), List.of("PROG")); 

        // PROG rule
        addEntry(table, "PROG", List.of("function", "class", "implementation", "comment", "multi_line_comment"), List.of("CLASSIMPLFUNC", "PROG"));
        addEntry(table, "PROG", List.of("$"), List.of("ε"));

        // CLASSIMPLFUNC rule
        addEntry(table, "CLASSIMPLFUNC", List.of("comment"), List.of("comment", "CLASSIMPLFUNC"));
        addEntry(table, "CLASSIMPLFUNC", List.of("multi_line_comment"), List.of("multi_line_comment", "CLASSIMPLFUNC"));
        addEntry(table, "CLASSIMPLFUNC", List.of("class"), List.of("CLASSDECL"));
        addEntry(table, "CLASSIMPLFUNC", List.of("implementation"), List.of("IMPLDEF"));
        addEntry(table, "CLASSIMPLFUNC", List.of("function"), List.of("FUNCDEF"));

        // CLASSDECL rule
        addEntry(table, "CLASSDECL", List.of("class"),
                List.of("class", "id", "ISA1", "lbrace", "VISMEMBERDECL", "rbrace", "semicolon"));

        // ISA1 rule
        addEntry(table, "ISA1", List.of("isa"), List.of("isa", "id", "ISA2"));
        addEntry(table, "ISA1", List.of("lbrace"), List.of("ε"));

        // ISA2 rule
        addEntry(table, "ISA2", List.of("comma"), List.of("comma", "id", "ISA2"));
        addEntry(table, "ISA2", List.of("lbrace"), List.of("ε"));

        // VISMEMBERDECL rule
        addEntry(table, "VISMEMBERDECL", List.of("public", "private"),
                List.of("VISIBILITY", "MEMDECL", "VISMEMBERDECL"));
        addEntry(table, "VISMEMBERDECL", List.of("rbrace"), List.of("ε"));

        // VISIBILITY rule
        addEntry(table, "VISIBILITY", List.of("public"), List.of("public"));
        addEntry(table, "VISIBILITY", List.of("private"), List.of("private"));

        // MEMDECL rule
        addEntry(table, "MEMDECL", List.of("function", "constructor"), List.of("FUNCDECL"));
        addEntry(table, "MEMDECL", List.of("attribute"), List.of("ATTRDECL"));

        // FUNCDECL rule
        addEntry(table, "FUNCDECL", List.of("function", "constructor"), List.of("FUNCHEAD", "semicolon"));

        // IMPLDEF rule
        addEntry(table, "IMPLDEF", List.of("implementation"),
                List.of("implementation", "id", "lbrace", "IMPLBODY", "rbrace"));

        // IMPLBODY rule
        addEntry(table, "IMPLBODY", List.of("function", "constructor"), List.of("FUNCDEF", "IMPLBODY"));
        addEntry(table, "IMPLBODY", List.of("rbrace"), List.of("ε"));

        // FUNCDEF rule
        addEntry(table, "FUNCDEF", List.of("function", "constructor"), List.of("FUNCHEAD", "FUNCBODY"));

        // FUNCHEAD rule
        addEntry(table, "FUNCHEAD", List.of("function"),
                List.of("function", "id", "lparen", "FPARAMS", "rparen", "arrow", "RETURNTYPE"));
        addEntry(table, "FUNCHEAD", List.of("constructor"),
                List.of("constructor", "lparen", "FPARAMS", "rparen"));

        // RETURNTYPE rule
        addEntry(table, "RETURNTYPE", List.of("int", "float", "id"), List.of("TYPE"));
        addEntry(table, "RETURNTYPE", List.of("void"), List.of("void"));

        // TYPE rule
        addEntry(table, "TYPE", List.of("int"), List.of("int"));
        addEntry(table, "TYPE", List.of("float"), List.of("float"));
        addEntry(table, "TYPE", List.of("id"), List.of("id"));

        // FUNCBODY rule
        addEntry(table, "FUNCBODY", List.of("lbrace"), List.of("lbrace", "LOCALVARDECLORSTAT2", "rbrace"));

        // LOCALVARDECLORSTAT rule
        addEntry(table, "LOCALVARDECLORSTAT", List.of("local"), List.of("LOCALVARDECL"));
        addEntry(table, "LOCALVARDECLORSTAT", List.of("id", "self", "if", "while", "read", "write", "return"),
                List.of("STATEMENT"));

        // LOCALVARDECLORSTAT2 rule
        addEntry(table, "LOCALVARDECLORSTAT2", List.of("comment"), List.of("comment", "LOCALVARDECLORSTAT2"));
        addEntry(table, "LOCALVARDECLORSTAT2", List.of("local", "id", "self", "if", "while", "read", "write", "return"),
                List.of("LOCALVARDECLORSTAT", "LOCALVARDECLORSTAT2"));
        addEntry(table, "LOCALVARDECLORSTAT2", List.of("rbrace"), List.of("ε"));

        // ATTRDECL rule
        addEntry(table, "ATTRDECL", List.of("attribute"), List.of("attribute", "VARDECL"));

        // LOCALVARDECL rule
        addEntry(table, "LOCALVARDECL", List.of("local"), List.of("local", "VARDECL"));

        // VARDECL rule
        addEntry(table, "VARDECL", List.of("id"), List.of("id", "colon", "TYPE", "ARRAYSIZES", "semicolon"));

        // ARRAYSIZES rule
        addEntry(table, "ARRAYSIZES", List.of("lsqbr"), List.of("ARRAYSIZE", "ARRAYSIZES"));  
        addEntry(table, "ARRAYSIZES", List.of("semicolon", "comma", "rparen"), List.of("ε"));  

        // ARRAYSIZE rule
        addEntry(table, "ARRAYSIZE", List.of("lsqbr"), List.of("lsqbr", "ARRAYSIZE2"));

        // ARRAYSIZE2 rule
        addEntry(table, "ARRAYSIZE2", List.of("intlit"), List.of("intlit", "rsqbr"));
        addEntry(table, "ARRAYSIZE2", List.of("rsqbr"), List.of("rsqbr"));

        // STATEMENT rule
        addEntry(table, "STATEMENT", List.of("id", "self"), List.of("FUNCALLORASSIGN", "semicolon"));
        addEntry(table, "STATEMENT", List.of("if"),
                List.of("if", "lparen", "RELEXPR", "rparen", "then", "STATBLOCK", "else", "STATBLOCK", "semicolon"));
        addEntry(table, "STATEMENT", List.of("while"),
                List.of("while", "lparen", "RELEXPR", "rparen", "STATBLOCK", "semicolon"));
        addEntry(table, "STATEMENT", List.of("read"),
                List.of("read", "lparen", "VARIABLE", "rparen", "semicolon"));
        addEntry(table, "STATEMENT", List.of("write"),
                List.of("write", "lparen", "EXPR", "rparen", "semicolon"));
        addEntry(table, "STATEMENT", List.of("return"),
                List.of("return", "lparen", "EXPR", "rparen", "semicolon"));

        // VARIABLE rule
        addEntry(table, "VARIABLE", List.of("id", "self"), List.of("IDORSELF", "VARIABLE2"));

        // VARIABLE2 rule
        addEntry(table, "VARIABLE2", List.of("lsqbr"), List.of("INDICES", "REPTVARIABLE"));
        addEntry(table, "VARIABLE2", List.of("lparen"), List.of("lparen", "APARAMS", "rparen", "VARIDNEST"));

        // REPTVARIABLE rule
        addEntry(table, "REPTVARIABLE", List.of("dot"), List.of("VARIDNEST", "REPTVARIABLE"));
        addEntry(table, "REPTVARIABLE", List.of("rparen", "semicolon"), List.of("ε"));

        // VARIDNEST rule
        addEntry(table, "VARIDNEST", List.of("dot"), List.of("dot", "id", "VARIDNEST2"));

        // VARIDNEST2 rule
        addEntry(table, "VARIDNEST2", List.of("lparen"), List.of("lparen", "APARAMS", "rparen", "VARIDNEST"));
        addEntry(table, "VARIDNEST2", List.of("lsqbr"), List.of("INDICES"));

        // FUNCALLORASSIGN rule
        addEntry(table, "FUNCALLORASSIGN", List.of("id", "self"), List.of("IDORSELF", "FUNCALLORASSIGN2"));

        // FUNCALLORASSIGN2 rule
        addEntry(table, "FUNCALLORASSIGN2", List.of("lsqbr", "assign", "dot"), List.of("INDICES", "FUNCALLORASSIGN3"));
        addEntry(table, "FUNCALLORASSIGN2", List.of("lparen"),
                List.of("lparen", "APARAMS", "rparen", "FUNCALLORASSIGN4"));

        // FUNCALLORASSIGN3 rule
        addEntry(table, "FUNCALLORASSIGN3", List.of("assign"), List.of("ASSIGNOP", "EXPR"));
        addEntry(table, "FUNCALLORASSIGN3", List.of("dot"), List.of("dot", "id", "FUNCALLORASSIGN2"));

        // FUNCALLORASSIGN4 rule
        addEntry(table, "FUNCALLORASSIGN4", List.of("dot"), List.of("dot", "id", "FUNCALLORASSIGN2"));
        addEntry(table, "FUNCALLORASSIGN4", List.of("semicolon"), List.of("ε"));

        // ASSIGNOP rule
        addEntry(table, "ASSIGNOP", List.of("assign"), List.of("assign"));

        // STATBLOCK rule
        addEntry(table, "STATBLOCK", List.of("lbrace"), List.of("lbrace", "STATEMENTS", "rbrace"));
        addEntry(table, "STATBLOCK", List.of("id", "self", "if", "while", "read", "write", "return"),
                List.of("STATEMENT"));
        addEntry(table, "STATBLOCK", List.of("else", "semicolon", "rsqbr"), List.of("ε"));
        addEntry(table, "STATBLOCK", 
                List.of("comment"), 
                List.of("comment", "STATBLOCK")); // Skip comments

        // STATEMENTS rule
        addEntry(table, "STATEMENTS", List.of("id", "self", "if", "while", "read", "write", "return"),
                List.of("STATEMENT", "STATEMENTS"));
        addEntry(table, "STATEMENTS", List.of("rbrace"), List.of("ε"));
        addEntry(table, "STATEMENTS", 
                List.of("comment"), 
                List.of("comment", "STATEMENTS")); // Skip comments

        // EXPR rule
        addEntry(table, "EXPR", List.of("id", "self", "floatlit", "intlit", "lparen", "not", "addition", "subtraction"),
                List.of("ARITHEXPR", "EXPR2"));

        // EXPR2 rule
        addEntry(table, "EXPR2", List.of("eq", "neq", "lt", "gt", "lteq", "gteq"), List.of("RELOP", "ARITHEXPR"));
        addEntry(table, "EXPR2", List.of("rparen", "semicolon", "comma", "rsqbr"), List.of("ε"));

        // RELEXPR rule
        addEntry(table, "RELEXPR", List.of("id", "self", "floatlit", "intlit", "lparen", "not", "addition", "subtraction"),
                List.of("ARITHEXPR", "RELOP", "ARITHEXPR"));

        // RELOP rule
        addEntry(table, "RELOP", List.of("eq"), List.of("eq"));
        addEntry(table, "RELOP", List.of("neq"), List.of("neq"));
        addEntry(table, "RELOP", List.of("lt"), List.of("lt"));
        addEntry(table, "RELOP", List.of("gt"), List.of("gt"));
        addEntry(table, "RELOP", List.of("lteq"), List.of("lteq"));
        addEntry(table, "RELOP", List.of("gteq"), List.of("gteq"));

        // ARITHEXPR rule
        addEntry(table, "ARITHEXPR", List.of("id", "self", "floatlit", "intlit", "lparen", "not", "addition", "subtraction"),
                List.of("TERM", "RIGHTRECARITHEXPR"));
        addEntry(table, "ARITHEXPR", List.of("rparen", "semicolon", "comma", "eq", "neq", "lt", "gt", "lteq", "gteq", "rsqbr"),
                List.of("ε"));

        // RIGHTRECARITHEXPR rule
        addEntry(table, "RIGHTRECARITHEXPR", List.of("addition", "subtraction", "or"),
                List.of("ADDOP", "TERM", "RIGHTRECARITHEXPR"));
        addEntry(table, "RIGHTRECARITHEXPR", List.of("rparen", "semicolon", "comma", "eq", "neq", "lt", "gt", "lteq", "gteq", "rsqbr"),
                List.of("ε"));

        // ADDOP rule
        addEntry(table, "ADDOP", List.of("addition"), List.of("addition"));
        addEntry(table, "ADDOP", List.of("subtraction"), List.of("subtraction"));
        addEntry(table, "ADDOP", List.of("or"), List.of("or"));

        // TERM rule
        addEntry(table, "TERM", List.of("id", "self", "floatlit", "intlit", "lparen", "not", "addition", "subtraction"),
                List.of("FACTOR", "RIGHTRECTERM"));

        // RIGHTRECTERM rule
        addEntry(table, "RIGHTRECTERM", List.of("*", "/", "and"), List.of("MULTOP", "FACTOR", "RIGHTRECTERM"));
        addEntry(table, "RIGHTRECTERM", List.of("rparen", "multiplication", "semicolon", "comma", "addition", "subtraction", "or", "eq", "neq", "lt", "gt", "lteq", "gteq", "rsqbr"),
                List.of("ε"));

        // MULTOP rule
        addEntry(table, "MULTOP", List.of("*"), List.of("*"));
        addEntry(table, "MULTOP", List.of("/"), List.of("/"));
        addEntry(table, "MULTOP", List.of("and"), List.of("and"));

        // FACTOR rule
        addEntry(table, "FACTOR", List.of("id", "self"),
                List.of("IDORSELF", "FACTOR2", "REPTVARIABLEORFUNCTIONCALL"));
        addEntry(table, "FACTOR", List.of("floatlit"), List.of("floatlit"));
        addEntry(table, "FACTOR", List.of("intlit"), List.of("intlit"));
        addEntry(table, "FACTOR", List.of("lparen"), List.of("lparen", "ARITHEXPR", "rparen"));
        addEntry(table, "FACTOR", List.of("not"), List.of("not", "FACTOR"));
        addEntry(table, "FACTOR", List.of("addition", "subtraction"), List.of("SIGN", "FACTOR"));

        // SIGN rule
        addEntry(table, "SIGN", List.of("addition"), List.of("addition"));
        addEntry(table, "SIGN", List.of("subtraction"), List.of("subtraction"));

        // FACTOR2 rule
        addEntry(table, "FACTOR2", List.of("lparen"), List.of("lparen", "APARAMS", "rparen"));
        addEntry(table, "FACTOR2", List.of("lsqbr"), List.of("INDICES"));
        addEntry(table, "FACTOR2", List.of("semicolon","addition", "lt", "subtraction", "rparen", "comma", "rsqbr", "multiplication", "leq", "dot"), List.of("ε"));

        // INDICES rule
        addEntry(table, "INDICES", List.of("lsqbr"), List.of("INDICE", "INDICES"));
        addEntry(table, "INDICES", List.of("rsqbr"), List.of("INDICE", "INDICES"));
        addEntry(table, "INDICES", List.of("assign","rparen", "semicolon", "comma", "dot", "addition", "subtraction", "or", "eq", "neq", "lt", "gt", "leq", "gteq", "*", "/", "and", "rsqbr"),
                List.of("ε"));

        // INDICE rule
        addEntry(table, "INDICE", List.of("lsqbr"), List.of("lsqbr", "ARITHEXPR", "rsqbr"));

        // REPTVARIABLEORFUNCTIONCALL rule
        addEntry(table, "REPTVARIABLEORFUNCTIONCALL", List.of("dot"), List.of("IDNEST", "REPTVARIABLEORFUNCTIONCALL"));
        addEntry(table, "REPTVARIABLEORFUNCTIONCALL", List.of("rparen", "subtraction", "semicolon", "comma", "addition", "or", "eq", "neq", "lt", "gt", "lteq", "gteq", "multiplication","*", "/", "and", "rsqbr"),
                List.of("ε"));

        // IDNEST rule
        addEntry(table, "IDNEST", List.of("dot"), List.of("dot", "id", "IDNEST2"));

        // IDNEST2 rule
        addEntry(table, "IDNEST2", List.of("lparen"), List.of("lparen", "APARAMS", "rparen"));
        addEntry(table, "IDNEST2", List.of("lsqbr"), List.of("INDICES"));

        // FPARAMS rule
        addEntry(table, "FPARAMS", List.of("id"), List.of("id", "colon", "TYPE", "ARRAYSIZES", "REPTFPARAMS1"));
        addEntry(table, "FPARAMS", List.of("rparen"), List.of("ε"));

        // REPTFPARAMS1 rule
        addEntry(table, "REPTFPARAMS1", List.of("comma"), List.of("FPARAMSTAIL", "REPTFPARAMS1"));
        addEntry(table, "REPTFPARAMS1", List.of("rparen"), List.of("ε"));

        // FPARAMSTAIL rule
        addEntry(table, "FPARAMSTAIL", List.of("comma"), List.of("comma", "id", "colon", "TYPE", "ARRAYSIZES"));

        // APARAMS rule
        addEntry(table, "APARAMS", List.of("id", "self", "floatlit", "intlit", "lparen", "not", "addition", "subtraction"),
                List.of("EXPR", "REPTAPARAMS1"));
        addEntry(table, "APARAMS", List.of("rparen"), List.of("ε"));

        // REPTAPARAMS1 rule
        addEntry(table, "REPTAPARAMS1", List.of("comma"), List.of("APARAMSTAIL", "REPTAPARAMS1"));
        addEntry(table, "REPTAPARAMS1", List.of("rparen"), List.of("ε"));

        // APARAMSTAIL rule
        addEntry(table, "APARAMSTAIL", List.of("comma"), List.of("comma", "EXPR"));

        // IDORSELF rule
        addEntry(table, "IDORSELF", List.of("id"), List.of("id"));
        addEntry(table, "IDORSELF", List.of("self"), List.of("self"));
        return table;
    }

    /**
     * Adds an entry to the parse table.
     *
     * @param table      The parse table.
     * @param nonTerminal The non-terminal symbol.
     * @param terminals   The list of terminal symbols.
     * @param production  The production rule.
     */
    private void addEntry(Map<String, Map<String, List<String>>> table, String nonTerminal, List<String> terminals, List<String> production) {
        for (String terminal : terminals) {
            table.computeIfAbsent(nonTerminal, k -> new HashMap<>())
                    .put(terminal, production);
        }
    }

    /**
     * Outputs the results of the parsing process, including errors and derivation steps.
     *
     * @throws IOException If an I/O error occurs during output.
     */
    private void outputResults() throws IOException {
        if (errorCount > 0) {
            System.out.println("Parsing completed with " + errorCount + " error(s).");
            errorFileGenerator.outputError(fileName, syntaxErrors.toString(), "Syntax");
            System.out.println(syntaxErrors.toString());
        } else {
            System.out.println("Parsing completed successfully.");
        }
        derivationBuilder.close();
    }
}